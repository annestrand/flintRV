#!/usr/bin/env python

# Copyright (c) 2023 - present, Austin Annestrand
# Licensed under the MIT License (see LICENSE file).

import os
import re
import inspect
import argparse
from enum import Enum

# Supported ISA configs
class CoreISAconfigs(Enum):
    RV32I   = 0
isa_table = {
    "rv32i"     : CoreISAconfigs.RV32I,
}

# Supported Interface schemes
class CoreInterfaceSchemes(Enum):
    NONE    = 0
interface_table = {
    "none"     : CoreInterfaceSchemes.NONE,
}

# =====================================================================================================================
def print_generated_banner():
    print("/"*120)
    print("//")
    print("// NOTICE!")
    print("//")
    print(f"// The following code/file was generated by: [ {os.path.basename(__file__)} ]")
    print("//")
    print("// (Do not attempt to edit this file. Regenerate using above script instead.)")
    print("//")
    print(("/"*120)+"\n")

# =====================================================================================================================
def build_top_module(args):
    # Defaults
    top_src             = ""
    xlen                = 32
    instr_width         = 32
    regfile_addr_width  =  5
    # Check ISA type
    if isa_table[args.ISA] == CoreISAconfigs.RV32I:
        xlen                = 32
        instr_width         = 32
        regfile_addr_width  =  5
    # Build top based on interface scheme
    if interface_table[args.interface] == CoreInterfaceSchemes.NONE:
        top_src += f"""
            module {args.topName} (
                input i_clk,
                input i_rst,
                input i_ifValid,
                input i_memValid,
                input [{instr_width-1}:0] i_instr,
                input [{xlen-1}:0] i_dataIn,
                output o_storeReq,
                output o_loadReq,
                output [{xlen-1}:0] o_pcOut,
                output [{xlen-1}:0] o_dataAddr,
                output [{xlen-1}:0] o_dataOut
            );
                drop32 #(
                    // CPU Configuration
                    .PC_START           ({args.pcStart}),
                    .REGFILE_ADDR_WIDTH ({regfile_addr_width}),
                    .INSTR_WIDTH        ({instr_width}),
                    .XLEN               ({xlen}),
                    .ICACHE_LATENCY     ({args.iLatency})
                ) drop32_unit (
                    .i_clk              (i_clk     ),
                    .i_rst              (i_rst     ),
                    .i_ifValid          (i_ifValid ),
                    .i_memValid         (i_memValid),
                    .i_instr            (i_instr   ),
                    .i_dataIn           (i_dataIn  ),
                    .o_storeReq         (o_storeReq),
                    .o_loadReq          (o_loadReq ),
                    .o_pcOut            (o_pcOut   ),
                    .o_dataAddr         (o_dataAddr),
                    .o_dataOut          (o_dataOut )
                );
            endmodule
        """
    return inspect.cleandoc(top_src).lstrip()

# =====================================================================================================================
def parse_has_err(args, unknown):
    file_name       = os.path.basename(__file__)
    args.interface  = str.lower(args.interface)
    args.ISA        = str.lower(args.ISA)
    args.pcStart    = int(args.pcStart, 16) if args.pcStart[:2] == "0x" else int(args.pcStart)
    args.iLatency   = int(args.iLatency)
    if len(unknown) != 0:
        print(f"[{file_name} - Error]: Unknown argument(s)/option(s): {unknown}\n")
        return False
    if args.interface not in interface_table:
        print(f"[{file_name} - Error]: Invalid interface option: [ {args.interface} ]")
        print(f"    Please use one of the following: {list(interface_table.keys())}\n")
        return False
    if args.ISA not in isa_table:
        print(f"[{file_name} - Error]: Invalid CPU ISA option: [ {args.ISA} ]")
        print(f"    Please use one of the following: {list(isa_table.keys())}\n")
        return False
    if not abs(int(args.pcStart)) <= 0xffffffff:
        print(f"[{file_name} - Error]: PC start value out of range: [ {args.pcStart} ].")
        print(f"    Valid range: [0x0 - 0xffffffff]\n")
        return False
    if args.iLatency < 0 or args.iLatency > 1:
        print(f"[{file_name} - Error]: Invalid instruction cache latency value: [ {args.iLatency} ].")
        print(f"    Valid values: [0 or 1] - 0:combinatorial, 1:BRAM\n")
        return False
    return True

# =====================================================================================================================
# Helper utility to generate and config CPU top module based on different interface schemes
# =====================================================================================================================
if __name__ == "__main__":
    parser = argparse.ArgumentParser(allow_abbrev=False,
        description="Helper utility to config CPU top module and generate top module to stdout.")
    parser.add_argument("-if", dest="interface", default="none",
        help="Specify which CPU interface to use [Default: None].")
    parser.add_argument("-isa", dest="ISA", default="rv32i",
        help="Specify which CPU ISA to use [Default: rv32i].")
    parser.add_argument("-pc", dest="pcStart", default="0",
        help="PC start/reset value (Prefix value with '0x' for hex). [Default: 0x0].")
    parser.add_argument("-name", dest="topName", default="top",
        help="Generated top module name. [Default: top].")
    parser.add_argument("-ilat", dest="iLatency", default="0",
        help="Latency of the attached instruction cache (0cc - 1cc). [Default: 0].")

    # Parse and err check
    args, unknown = parser.parse_known_args()
    if not parse_has_err(args, unknown):
        parser.print_help()
        exit(1)

    # Create top module source based on interface choice
    top_src = build_top_module(args)

    # Dump final src file to stdout
    src_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), "..", "rtl"))
    srcs = [x for x in os.listdir(src_dir) if x != "types.vh"]
    print_generated_banner()
    with open(os.path.join(src_dir, "types.vh"), 'r') as core_header_fp:
        print(core_header_fp.read())
        print("// " +"="*116)
        for src_file in srcs:
            with open(os.path.join(src_dir, src_file)) as src_file_fp:
                src_code = src_file_fp.read()

                # Remove unwanted items from final file
                src_code = re.sub(r"`include .*\n\n", "", src_code)
                src_code = re.sub(r"`VP", "   ", src_code)
                src_code = re.sub(r"// Copyright.*" + (r"\n.*" * 2) + r"\n", "", src_code)

                print(src_code)
                print("// " +"="*116)
    print(top_src)